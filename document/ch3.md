# Chapter3. 코드에서 나는 악취

## 3.1 기이한 이름 (Mysterious Name)

코드는 단순하고 명료하게 작성헤야 한다.


## 3.2 중복 코드 (Duplicated Code)

코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.


## 3.3 긴 함수 (Long Function)

함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.

'무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

## 3.4 긴 매개변수 목록 (Long Parameter List)

매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

종종 다른 매개변수에서 값을 얻어올 수 있는데 , 이런 매개변수는 **매개변수를 질의 함수로 바꾸기** 로 제거할 수 있다.
사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 **객체 통째로 넘기기** 를 적용해서 원본 데이터 
 구조를 그대로 전달한다.

## 3.5 전역 데이터 (Global Data)

전역 데이터는 코드베이스 어디에서든 건드릴 수 없고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.


## 3.6 가변 데이터 (Mutable Data)

데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다.
코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하 못한 채 수정해버리면 프로그램이 오작동한다.

무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.
가령 **변수 캡슐화히기** 를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지
감시하거나 코드를 개선하 쉽다.

## 3.7 뒤엉킨 변경 (Divergent Change)

코드를 수정할 때는 시스템에서 고쳐야할 딱 한 군데를 찾아서 그 부분만 수정 할 수 있기를 바란다.
이렇게 할 수 없다면 뒤엉킨 변경과 산탄 총 수술 중 하나가 풍긴다.

뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다. 

## 3.8 산탄총 수술 (Shotgun Surgery)

이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

## 3.9 기능 편애(Feature Envy)

프로그램을 모듈할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 
상호작용은 최소로 줄이는 데 주력한다.

기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 많을 때
풍기는 냄새다.


## 3.10 데이터 뭉치 (Data Clumps)

데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다.

몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다.

## 3.11 기본형 집착 (Primitive Obsession)

기본형을 객체로 바꾸기를 적용하면 기본형만이 거주하는 구석기 동굴을 의미 있는 자료형들이 사는 최신 온돌식 코드로 탈바꿈 시킬 수 있다.

## 3.12 반복되는 switch 문 (Repeated Switched)

중복된 switch 문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch 문 들도 모두 찾아서 함께 수정해야 하기 때문이다.
이럴 때 다형성은 반복된 switch 문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기인 셈이다.


## 3.13 반복문 (Loops)

지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 **반복문을 파이프라인으로 바꾸기** 를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.
필터 나 맵 같은 파이프라 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 3.14 성의 없는 요소 (Lazy Element)

우리는 코드의 구조를 잡을 때 프로그램 요소를 이용하는 걸 좋아한다. 그래야 그 구조를 변형하거나 재활용할 기회가 생기고,
혹은 단순히 더 의미 있는 이름을 가졌기 때문이다. 그렇지만 그 구조가 필요 없을 때도 있다.

사정이 어떠하든 이런 프로그램 요소는 고이 보내드는 게 좋다.

## 3.15 추측성 일반화 (Speculative Generality)

이 냄새는 '나중에 필요할거야' 라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.

하는 일이 거의 없는 추상 클래스는 **계층 합치기** 로 제거한다. 쓸데없이 위임하는 코드는 **함수 인라인 하기** 나 **클래스 인라인하기** 로 삭제한다.
본문에서 사용되지 않는 매개변수는 **함수 선언 바꾸기** 로 없앤다.

## 3.16 임시 필드 (Temporary Field)

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는 게 보통이라,
이렇게 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.

덩그러니 떨어져 있는 필드들을 발견하면 **클래스 추출하기** 로 제 살 곳을 찾아준다. 그런 다음 **함수 옮기기** 로 임시 필드들과 관련된 코드를
모조리 새 클래스에 몰아넣는다.

## 3.17 메시지 체인 (Message Chains)

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로 , 
다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

## 3.18 중개자 (Middle Man)

객체의 대표적인 기능 중 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 
캡슐화하는 과정에서 위임이 자주 활용된다. 

## 3.19 내부자 거래 (Insider Trading)

소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아하며, 그래서 모듈 사이의 데이터 거래가 많으면 결합도가 높아진다고 투덜댄다.
일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만 ,  그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

## 3.20 거대한 클래스 (Large Class)

한 클래스가 너무 많은 일을 하면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 
너무 많으면 중복 코드가 생기기 쉽다.

이럴 때는 **클래스 추출하기** 로 필드들 일부를 따로 묶는다.
같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면 된다.

필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다.
가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다. 

## 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다.


## 3.22 데이터 클래스 (Data Class)

데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.

다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아서 함소 옮기기로 그 메서드를 데이터 클래스로 옮길 수 있는지 살펴보자.

데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의 돼 있다는 신호일 수 있다.
이런 경우라면 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.

## 3.23 상속 포기 ( Refused Bequest)

서브클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나 필요 없다면 어떻게 해야 할까?
 수많은 유산 중에서 관심 있는 몇 개만 받고 끝내려는 경우는 얼마든지 있을 수 있다.

상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도다.

이럴 때는 서브클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 활용해서 아예 상송 메커니즘에서 벗어나보자.

## 3.24 주석 (Comments)

주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다.

주석이 많으면 이 장에서 소개한 온갖 악취를 풍기는 코드가 나오기 쉽다.

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 함수 추출하기를 적용해본다.
이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 함수 선언 바꾸기로 함수 이름을 바꿔본다.

> 주석을 남겨야겠단느 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다.



